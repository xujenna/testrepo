
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8" />
<title>Correlation Matrix</title>
<style>

body {
/*  background-color:#fcf9ef;
*/  text-align: center;
  font-family: fanwood, serif;
  font-size:17px;
  font-style: text;
  text-align: center;
  letter-spacing: 0.5px;
}
  h2 {
    font-family: europa, sans-serif;
    font-size:28px;
    letter-spacing: 1px;
    font-weight:900;
    /*border-bottom: 1px solid;*/
  }

  .tooltip {
    width: 200px;
    font-family: europa, sans-serif;
    font-style: light;
    font-size: 12px;
    background:rgba(255,255,255,0.65);
    padding:5px;
    line-height:1.25;
    clear:both;
    text-align: center;
  }



  .n::after {
    font-size:18px;
    width: 200px;
    color: black;
    content: "\2193";
    position:absolute;
    text-align:center;
    display:block;
    pointer-events:none;
    margin-top:5px;
  }

.smallAxisLabel, .smallAxis text {
  font-size:8.5px;
  font-family: europa, sans-serif;
}

.matrix-label {
  font-size:8.5px;
  font-family: europa, sans-serif;
  transform:rotate(-45deg);
}
.regression {
  stroke-width: 2px;
/*  stroke: black;
*/  stroke-dasharray: 3.5,1.5;
}

.axis line,
  .axis path,
  .smallAxis line,
  .smallAxis path {
    fill:none;
    stroke:silver;
    stroke-width:1;
  }

  .tick line {
    fill: none;
    stroke-dasharray: 2px 4px;
  }

  .axisLabel, .axis text {
    fill: black;
    font-family: europa, sans-serif;
    font-style: light;
    text-transform: uppercase;
    font-size: 10px;
    letter-spacing: 1px;
}

.axisLabel {
 letter-spacing: 2.5px;
 font-weight: bold;
}

#intro-text {
  width:60%;
  margin:auto;
/*  column-count: 3;
  column-gap: 30px;*/
  text-align: left;
  line-height: 22px;
}

#correlation-container {
  width:100%;
  display:inline-block;
/*  overflow: auto;
*/  /*background-color: silver;*/
  margin:auto;
  padding: 0 0 0 0;
  text-align: center;
}

  .container {
    overflow: hidden;
    margin-top: 70px;
    margin-bottom: 150px;
    display:block;
    width:100%;
  }

  #correlationintro-container{
    padding-top: 70px;
    padding-bottom: 150px;
    background-color:#fcf9ef;
    margin-bottom: 0px;
  }

  .description {
    display:inline-block;
    width:20%;
    text-align: left;
    margin-top: 30px;
    padding-right: 60px;
    vertical-align:top;
  }
.dropdown {
  margin: auto;
  display: inline-block;
  width:300px;
  margin-top: 100px;
}

#variable-description-container{
  width:100%;
  display: inline-block;
  margin:auto;
  margin-top:50px;
  font-size: 11px;
  font-family: europa, sans-serif;
  text-align: left;
  padding:14px;
  border: 1px solid black;
}
#variable-description-title {
  padding-bottom: 10px;
  border-bottom: 1px solid black;
  margin-bottom: 10px;
  font-weight: bold;
}

#variable-description {
  column-count: 2;
  column-gap: 7px;
}
#variable-description p {
  margin:5px;
  -webkit-column-break-inside: avoid;
          page-break-inside: avoid;
               break-inside: avoid;
}

/*#correlationintro-container .description {
  margin-top: 0px;
}

#correlationintro-container .container{
  margin-bottom: 50px;
}*/

</style>
</head>
<body>
    <link rel="stylesheet" href="https://use.typekit.net/fao6qlb.css">
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://d3js.org/d3-time.v1.min.js"></script>
  <script src="d3-tip.js"></script>

<div class="container" id="correlationintro-container">
  <div class="description">
    <h2>Metric Relationships</h2>
    To get a sense of emerging correlations, we can look at 1) scatterplots, the shape of which suggests strength of correlation, 2) linear regression, the slope of which expresses the magnitude of how <span style="color:rgb(255, 0, 255)"><b>positive</b></span> or <span style="color:rgb(0, 0, 255)"><b>negative</b></span> a correlation is, and 3) Pearson coefficients, which measure the linear correlation between two variables within a range of -1 to 1.
    <p>A correlation matrix that depicts current pearson coefficients can be generated by comparing "All" with "All" in the dropdown menus, below. Comparing a specific metric with "All" will generate scatterplots and trendlines.</p>

    <form>
    <select id = "selection1">
    <option selected="selected"><b>Select an X-Axis Metric:</b></option>
    </select>
    </form>
<!--     <p class="dropdown-instructions">Select a y-axis metric:</p>
 -->    <form>
      <select id = "selection2">
      <option selected="selected"><b>Select an Y-Axis Metric:</b></option>
      </select>
    </form>
  <div id="variable-description-container">
  <div id="variable-description-title">METRICS DESCRIPTIONS</div>
  <div id="variable-description"></div>
</div>
  </div>
  <svg id="correlations"></svg>
</div>



<script>

// correlation matrix adapted from https://bl.ocks.org/emeeks/671c0e7adfb1ce7060b8
// linear regression adapted from https://bl.ocks.org/HarryStevens/be559bed98d662f69e68fc8a7e0ad097

// colors = d3.scale.ordinal().range(["gold", "springgreen", "magenta", "blue", "deeppink", "cyan"]);

// colors = d3.scale.ordinal().range(["#827abf", "#f62150", "#6f89b6", "#f5e0b7", "#5b1e37", "#b9e3c5"]);

d3.tsv("mergedDF.tsv", function(err, data) {
  d3.tsv("correlationmatrix.tsv", function(err, correlationData) {
      if (err) console.warn(err, "error loading data");


var correlationSVG = d3.select("#correlations")
.attr("width", 1000)

var margin = {top: 80, right: 80, left:80, bottom: 80}

  // attributes = d3.keys(data[0])
  attributes = ["All", "mood", "social", "alone", "morale", "stress", "fatigue", "compulsions", "leisure_activity", "feedly_activity", "with_friends_activity", "errands_activity", "ash_stuff_activity", "chatting_activity", "with_k_activity", "in_class_activity", "therapy_activity", "home_location", "school_location", "kevin_home_location", "Sadness_score", "Analytical_score", "Joy_score", "Fear_score", "Tentative_score", "Anger_score", "Confident_score", "blinks", "max_attention", "max_valence", "productivity_score"]
    // attributes = ["mood", "social", "morale", "stress", "fatigue", "compulsions", "productivity_score", "blinks", "Sadness_score", "Joy_score", "Tentative_score", "Confident_score", "min_attention", "min_valence", "feedly_activity", "with_k_activity", "with_friends_activity", "leisure_activity", "home_location", "school_location", "All"]

    attribute_descriptions = {mood: "Mood Reporter data on scale of 0-5", social: "Mood Reporter data on number of social interactions", alone: "Mood Reporter data (T/F)", morale: "Mood Reporter data on scale of 0-5", stress: "Mood Reporter data on scale of 0-5", fatigue: "Mood Reporter data on scale of 0-5", compulsions: "Mood Reporter data on compulsions (T/F)", productivity_score: "Productivity_score, calculated by the RescueTime App on scale of 0-100%", blinks: "Count per minute, calculated with Facial Analysis data", Sadness_score: "Sentiment analysis score from Keylogger data", Joy_score: "Sentiment analysis score from Keylogger data", Tentative_score: "Sentiment analysis score from Keylogger data", Confident_score: "Sentiment analysis score from Keylogger data", Analytical_score: "Sentiment analysis score from Keylogger data", Fear_score: "Sentiment analysis score from Keylogger data", Anger_score: "Sentiment analysis score from Keylogger data", max_attention: "Max attention score calculated with Facial Analysis data", max_valence: "Max valence score calculated with Facial Analysis data", feedly_activity: "Mood Reporter data on usage of Feedly (T/F)", with_k_activity: "Mood Reporter data on time with boyfriend (T/F)", with_friends_activity: "Mood Reporter data on time with friends (T/F)", leisure_activity: "Mood Reporter data on leisure time (T/F)", errands_activity: "Mood Reporter data on time spent on errands (T/F)", ash_stuff_activity: "Mood Reporter data on time spent on pro bono work (T/F)", chatting_activity: "Mood Reporter data on time spent chatting (T/F)", in_class_activity: "Mood Reporter data on time spent in class (T/F)", therapy_activity: "Mood Reporter data on time spent in therapy (T/F)", home_location: "Mood Reporter data on time spent at home (T/F)", school_location: "Mood Reporter data on time spent at school (T/F)", kevin_home_location: "Mood Reporter data on time spent at boyfriend's house (T/F)", All: "All variables"}


  d3.select("#selection1").selectAll("options")
    .data(attributes)
    .enter().append("option")
    .text(function(d){console.log(d);return d})

  d3.select("#selection2").selectAll("options")
    .data(attributes)
    .enter().append("option")
    .text(function(d){return d})

  attributeMatrix = [];

  attributes.forEach(function(a,x) {
    attributes.forEach(function(b,y){
      if(y == attributes.length || x == attributes.length){
        return
      }
      else{
      attributeMatrix.push({a: a, b:b, x:x, y:y})
    }
    })
  })


  data.forEach(function (d) {
    attributes.forEach(function (att) {
      if(d[att] == "False"){
        d[att] = 0;
      }
      else if (d[att] == "True") {
        d[att] = 1;
      }
      else {
        d[att] = parseFloat(d[att])
      }
    })
  })

  //create scales dynamically for each attribute's extent

  scale = {};
  attributes.forEach(function (att) {
    scale[att] = d3.scaleLinear();
    attExtent = d3.extent(data, function (d) {return d[att]});
    scale[att].domain(attExtent);
  })


var selection1 = document.querySelector('#selection1');
selection1.addEventListener('input', getInput)

var selection2 = document.querySelector('#selection2');
selection2.addEventListener('input', getInput)

function getInput() {

  var input1 = document.getElementById("selection1").value
  var input2 = document.getElementById("selection2").value


  var newMatrix = [];
  var attributeSet = new Set()

  if(input1 == "Select an X-Axis Metric:" || input2 == "Select an Y-Axis Metric:"){
    return
  }
  if(input1 == "All" && input2 =="All"){

    attributeSet = new Set(attributes);

    correlationData.forEach(function(d){
      if(attributeSet.has(d.index)){
        attributeSet.forEach(function(att){
          if(att != "All"){
          newMatrix.push({a: d.index, b:att, corr: d[att]})
          }
        })

      }
    })

  }
  else if(input1 == "All") {
    attributeSet.add(input2)
    attributeMatrix.forEach(function(d){
      if(d.b == input2) { 
        if(d.a != "All" && d.a != d.b) {
          newMatrix.push(d)
          attributeSet.add(d.a)
        }        

      }
    })
  }
  else if (input2 == "All"){
    attributeSet.add(input1)
    attributeMatrix.forEach(function(d){
      if(d.a == input1) {
        if(d.b != "All" && d.b != d.a) {
          newMatrix.push(d)
          attributeSet.add(d.b)
        }        

      }
    })
  }
  else {
    newMatrix.push({a: input1, b:input2})
    attributeSet.add(input1)
    attributeSet.add(input2)

  }

  var variable_description = document.querySelector("#variable-description")
  variable_description.innerHTML = null


attributeSet.forEach(function(d){
  // var newP = document.createTextNode("<b>"+ d + ": </b>" + attribute_descriptions[d])
  var newP = document.createElement("p")

  var newPair = "<b>"+ d + ": </b>" + attribute_descriptions[d]

  newP.innerHTML = newPair

  variable_description.appendChild(newP)

})

attributeSet.clear()



if(newMatrix.length > 300) {
  var containerWidth = 1000/34.5;
  var containerHeight = 1000/34.5;
  var chartHeight = 1000/36.5;
  var chartWidth = 1000/36.5;
  var rowLength = 30;
}
else if(newMatrix.length < 300 && newMatrix.length > 2){
  var containerWidth = 1000/5.25;
  var containerHeight = 1000/5.25;
  var chartHeight = 1000/7;
  var chartWidth = 1000/7;
  var rowLength = 5;
  var tickNumX = 4;
  var tickNumY = 4;
  var tickSize = 2;
  var tickPadding = 2;
  var axisClass = "smallAxis";
  var radius = 2;
  var labelClass = "smallAxisLabel"
}
else if (newMatrix.length < 2){
  var containerWidth = 1000/2;
  var containerHeight = 1000/2.5;
  var chartHeight = 400;
  var chartWidth = 900;
  var rowLength = 1;
  var tickNumX = 12;
  var tickNumY = 6;
  var tickSize = -chartWidth;
  var tickPadding = 10;
  var axisClass = "axis";
  var radius = 4;
  var labelClass = "axisLabel"
}

// 
// d3.select("svg")
correlationSVG
.html("")
.attr("height", Math.ceil((newMatrix.length / rowLength)  * containerHeight) + margin.top + margin.bottom)
.attr("width", 1000)


var rows = 0;
var j = -1;

correlationSVG  
  .selectAll("g")
  .data(newMatrix)
  .enter()
  .append("g")
  .attr("transform", function (d,i) {
      if(i > 0 && i%rowLength == 0){
        rows += 1;
        j=0;
        return "translate(" + ((j * containerWidth) + margin.left) + "," + ((rows * containerHeight) + margin.top) + ")" 
      }
      else{
        j +=1;
        return "translate(" + ((j * containerWidth) + margin.left) + "," + ((rows * containerHeight) + margin.top) + ")" 

      }
  });



d3.selectAll("g").each(function(pair,i){

  if(pair.a == pair.b && newMatrix.length < 2){
    return
  }
  else if(newMatrix.length < 300) {

    scale[pair.a].range([0,chartWidth]);
    scale[pair.b].range([chartHeight,0]);

    d3.select(this).append("rect").style("fill", "none").style("stroke", "none").style("stroke-width", 0)
    .attr("height", chartHeight)
    .attr("width", chartWidth)

      var xAxisCorr = d3.axisBottom()
          .scale(scale[pair.a])
          .tickSize(3)
          .ticks(tickNumX)
          .tickPadding(tickPadding);

      var yAxisCorr = d3.axisLeft()
          .scale(scale[pair.b])
          .tickSize(tickSize)
          .ticks(tickNumY)
          .tickPadding(tickPadding);

      d3.select(this).append("g")
        .attr("class", axisClass)
        .attr("transform", "translate(0," + chartHeight + ")")
        .call(xAxisCorr)

      d3.select(this).append("g")
          .attr("class", axisClass)
          .call(yAxisCorr);

      if(newMatrix.length > 2){
          d3.select(this).append("text")
          .attr("class", labelClass)
          .attr("x", (chartWidth/2) + 5)
          .style("text-anchor", "middle")
          .attr("y", 7)
          .attr("fill", "black")

          .text(function(d){
            var string = pair.a + pair.b;

            if(string.length <= 20){
              return pair.a.toUpperCase() + " - " + pair.b.toUpperCase();
            }
            else if(string.length > 20){
              return pair.a.toUpperCase() + " -";
            }
          })
          d3.select(this).append("text")
          .attr("class",labelClass)
          .attr("x", (chartWidth/2) + 5)
          .style("text-anchor", "middle")
          .attr("y", 20)
          .attr("fill", "black")
          .text(function(d){
            var string = pair.a + pair.b;
            if(string.length > 20){
              return pair.b.toUpperCase()
            }
          });
        }
      else if (newMatrix.length < 2){
        d3.select(this).append("text")
          .attr("class", labelClass)
          .attr("x", (chartWidth/2))
          .attr("y", chartHeight + 60)
          .attr("fill", "black")
          .text(function(d){
            return pair.a
          })
       d3.select(this).append("text")
          .attr("class", labelClass)
          .attr("transform", "rotate(-90)")
          .attr("x", 0 - (chartHeight/2))
          .attr("y", -50)
          .style("text-anchor", "middle")
          .attr("fill", "black")
          .text(function(d){
            return pair.b
          })
      }
    }
    else if (newMatrix.length >300) {
      scale[pair.a].range([4,chartWidth]);
      scale[pair.b].range([chartHeight,4]);

      var corr_color = d3.scaleLinear()
        .domain([-1,0,1])
        .range(["blue", "#fcf9ef", "magenta"])

      d3.select(this).append("rect").style("fill", corr_color(pair.corr)).style("stroke", "#fcf9ef").style("stroke-width", 1.5)
      .attr("height", containerHeight)
      .attr("width", containerWidth)


      if (i == 0) {
        d3.select(this).append("text")
        .attr("class", "matrix-label")
        .attr("x", 10)
        .attr("y", 5)
        .attr("fill", "black")
        .text(pair.b.toUpperCase())  
        d3.select(this).append("text")
        .attr("class", "matrix-label")
        .attr("x", -10)
        .attr("y", 5)
        .attr("fill", "black")
        .style("text-anchor", "end")
        .text(pair.a.toUpperCase())
      }
      else if(i < 30){
        d3.select(this).append("text")
        .attr("class", "matrix-label")
        .attr("x", 10)
        .attr("y", 5)
        .attr("fill", "black")
        .text(pair.b.toUpperCase())  
      }
      else if(i%30 == 0){
        d3.select(this).append("text")
        .attr("class", "matrix-label")
        .attr("x", -10)
        .attr("y", 5)
        .attr("fill", "black")
        .style("text-anchor", "end")
        .text(pair.a.toUpperCase())
      }

  var corrTip = d3.tip()
    .attr("class", "tooltip")
    .offset([-20,-5])
    .html(function(d,i) {
    return "<b>" + d.a + ",<br>" + d.b + ":</b><br>" + d.corr;
    });

   correlationSVG.selectAll("rect")
    .call(corrTip)

    .on("mouseover", function(d) {
      corrTip.show(d);
    })

    .on("mouseout", function(d) {
      corrTip.hide(d);
    })
    return
  }



    var lg = calcLinear(data, pair.a, pair.b, 
          d3.min(data, function(d){ return d[pair.a] }), 
          d3.min(data, function(d){ return d[pair.b] }), 
          d3.max(data, function(d){ return d[pair.a] }));

    var circleclass;

    d3.select(this).append("line")
          .attr("class", "regression")
          .attr("x1", scale[pair.a](lg.ptA.x))
          .attr("y1", scale[pair.b](lg.ptA.y))
          .attr("x2", scale[pair.a](lg.ptB.x))
          .attr("y2", scale[pair.b](lg.ptB.y))
          .attr("stroke", function(d){
            if (pair.b == pair.a){
              circleclass = "silver";
              return "silver";
            }
            else if((scale[pair.b](lg.ptA.y)) >(scale[pair.b](lg.ptB.y))){
              circleclass = "magenta";
              return "magenta";
            }
            else {
              circleclass = "blue";
              return "blue";
            }
          });

        // scatterplot points
      d3.select(this).selectAll("circle")
      .data(data)
      .enter()
      .append("circle")
      .attr("r", radius)
      .style("fill", circleclass)
      // .style("fill", colors(i))
      .style("opacity", 0.11)
      .attr("cx", function (d) {
        return scale[pair.a](d[pair.a])
      })
      .attr("cy", function (d) {return scale[pair.b](d[pair.b])});

   // }
    })


   // Calculate a linear regression from the data

    // Takes 5 parameters:
    // (1) Your data
    // (2) The column of data plotted on your x-axis
    // (3) The column of data plotted on your y-axis
    // (4) The minimum value of your x-axis
    // (5) The minimum value of your y-axis

    // Returns an object with two points, where each point is an object with an x and y coordinate

    function calcLinear(data, x, y, minX, minY, maxX){
      /////////
      //SLOPE//
      /////////

      // Let n = the number of data points
      var n = data.length;

      // Get just the points
      var pts = [];
      data.forEach(function(d,i){
        // console.log("+d[x]", +d[x])
        var obj = {};
        obj.x = +d[x];
        obj.y = +d[y];
        obj.mult = obj.x*obj.y;
        pts.push(obj);
      });

      // Let a equal n times the summation of all x-values multiplied by their corresponding y-values
      // Let b equal the sum of all x-values times the sum of all y-values
      // Let c equal n times the sum of all squared x-values
      // Let d equal the squared sum of all x-values
      var sum = 0;
      var xSum = 0;
      var ySum = 0;
      var sumSq = 0;
      pts.forEach(function(pt){
        // console.log(pt)
        sum = sum + pt.mult;
        xSum = xSum + pt.x;
        ySum = ySum + pt.y;
        sumSq = sumSq + (pt.x * pt.x);
      });

      var a = sum * n;
      var b = xSum * ySum;
      var c = sumSq * n;
      var d = xSum * xSum;


      // Plug the values that you calculated for a, b, c, and d into the following equation to calculate the slope
      // slope = m = (a - b) / (c - d)
      var m = (a - b) / (c - d);
      /////////////
      //INTERCEPT//
      /////////////

      // Let e equal the sum of all y-values
      var e = ySum;
      // Let f equal the slope times the sum of all x-values
      var f = m * xSum;
      // Plug the values you have calculated for e and f into the following equation for the y-intercept
      // y-intercept = b = (e - f) / n
      var b = (e - f) / n;

      // return an object of two points
      // each point is an object with an x and y coordinate
      return {
        ptA : {
          x:minX,
          y: m * minX + b
          // x: minX,
          // y: m * minX + b
        },
        ptB : {
          x: maxX,
          y: m * maxX + b
          // y: minY,
          // x: (minY - b) / m
        }
      }
    }

}
  })
});



</script>
</body>
</html>